"""Gherkin/BDD .feature file generator with state-based scenarios."""
from models.test_plan import TestPlan
from models.context import SystemContext


def generate_gherkin(test_plan: TestPlan, context: SystemContext | None = None) -> str:
    """
    Generate Gherkin .feature file from a test plan.

    Produces domain-aware Given/When/Then steps with state-based scenarios,
    role-based access testing, and field validation coverage.

    Args:
        test_plan: TestPlan with scenarios
        context: SystemContext for endpoint metadata

    Returns:
        Gherkin .feature file content
    """
    endpoint_lookup = {}
    if context:
        for ep in context.endpoints:
            endpoint_lookup[ep.name] = ep

    lines = [
        "@generated @mindflayer",
        "Feature: API Test Suite",
        f"  {test_plan.rationale}",
        "",
        "  Background:",
        '    Given the API server is running',
        '    And the base URL is "http://localhost:8000"',
        "",
    ]

    # Group scenarios by endpoint
    endpoint_groups: dict[str, list] = {}
    for scenario in test_plan.scenarios:
        if scenario.endpoint not in endpoint_groups:
            endpoint_groups[scenario.endpoint] = []
        endpoint_groups[scenario.endpoint].append(scenario)

    for endpoint_name, scenarios in endpoint_groups.items():
        ep = endpoint_lookup.get(endpoint_name)
        method = ep.method if ep else "GET"
        path = ep.url_path if ep else "/"

        lines.append(f"  # ── {endpoint_name}: {method} {path} ──")
        lines.append("")

        for scenario in scenarios:
            test_type = scenario.test_type
            tags = _get_tags(test_type)
            lines.append(f"  {tags}")

            lines.append(f"  Scenario: {scenario.description}")

            # Generate Given/When/Then based on test type
            steps = _generate_steps(scenario, ep, method, path)
            for step in steps:
                lines.append(f"    {step}")

            lines.append("")

    # Footer
    lines.append("  # ── Coverage Summary ──")
    lines.append(f"  # Total scenarios: {len(test_plan.scenarios)}")
    lines.append(f"  # {test_plan.rationale}")
    lines.append("  # Generated by MindFlayer — AI-powered test intelligence")

    return "\n".join(lines)


def _get_tags(test_type: str) -> str:
    """Get Gherkin tags for a test type."""
    tags_map = {
        "positive": "@positive @smoke",
        "no_auth": "@security @negative",
        "dependency_failure": "@dependency @negative",
        "invalid_input": "@negative @error-handling",
        "state_conflict": "@state @business-rule @negative",
        "forbidden_role": "@security @rbac @negative",
        "field_validation": "@validation @negative",
        "boundary_value": "@validation @boundary @negative",
    }
    return tags_map.get(test_type, "@test")


def _generate_steps(scenario, ep, method: str, path: str) -> list[str]:
    """Generate Given/When/Then steps for a scenario."""
    test_type = scenario.test_type
    test_path = path.replace(":id", "test-id-123")
    requires_auth = ep.requires_auth if ep else False

    steps = []

    if test_type == "positive":
        if method in ("POST", "PUT", "PATCH"):
            steps.append(f'Given a valid request payload for "{ep.name if ep else "endpoint"}"')
            # Add domain-specific payload fields
            if ep and ep.request_body:
                for field in ep.request_body[:3]:  # Show top 3 fields
                    steps.append(f'And the "{field.name}" is "{field.example_value()}"')
        else:
            steps.append(f'Given a valid resource exists at "{test_path}"')

        if requires_auth:
            steps.append("And the user is authenticated")

        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append("And the response body should contain valid data")

    elif test_type == "no_auth":
        if method in ("POST", "PUT", "PATCH"):
            steps.append(f'Given a valid request payload for "{ep.name if ep else "endpoint"}"')
        else:
            steps.append(f'Given a valid resource exists at "{test_path}"')
        steps.append("And no authentication credentials are provided")
        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append('And the response should indicate authentication is required')

    elif test_type == "dependency_failure":
        steps.append(f'Given the required dependency has not been fulfilled')
        if requires_auth:
            steps.append("And the user is authenticated")
        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append('And the response should indicate the dependency error')

    elif test_type == "invalid_input":
        steps.append(f'Given a non-existent resource ID "nonexistent-id-999"')
        if requires_auth:
            steps.append("And the user is authenticated")
        invalid_path = path.replace(":id", "nonexistent-id-999")
        steps.append(f'When I send a {method} request to "{invalid_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append('And the response should indicate the resource was not found')

    elif test_type == "state_conflict":
        # Domain-specific state constraint scenario
        hint = scenario.payload_hint or {}
        state_field = next(iter(hint), "status")
        state_value = hint.get(state_field, "invalid_state")
        steps.append(f'Given a resource exists with {state_field} "{state_value}"')
        if requires_auth:
            steps.append("And the user is authenticated")
        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append(f'And the response should indicate a state conflict')
        # Show the business rule
        if ep and ep.state_constraints:
            constraint = ep.state_constraints[0]
            if constraint.allowed_values:
                steps.append(
                    f'And the error should explain that the operation requires '
                    f'{constraint.field} to be in {constraint.allowed_values}'
                )

    elif test_type == "forbidden_role":
        steps.append(f'Given the user has an unauthorized role')
        if scenario.payload_hint:
            role = next(iter(scenario.payload_hint.values()), "viewer")
            steps.append(f'And the user role is "{role}"')
        if method in ("POST", "PUT", "PATCH"):
            steps.append(f'Given a valid request payload for "{ep.name if ep else "endpoint"}"')
        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append('And the response should indicate insufficient permissions')

    elif test_type == "field_validation":
        hint = scenario.payload_hint or {}
        omit_field = hint.get("_omit_field")
        if omit_field:
            steps.append(f'Given a request payload without the required field "{omit_field}"')
        else:
            invalid_field = next((k for k in hint if k != "_omit_field"), "field")
            invalid_value = hint.get(invalid_field, "invalid")
            steps.append(f'Given a request payload with invalid {invalid_field} "{invalid_value}"')
        if requires_auth:
            steps.append("And the user is authenticated")
        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append('And the response should explain the validation error')

    elif test_type == "boundary_value":
        hint = scenario.payload_hint or {}
        field_name = next(iter(hint), "field")
        field_value = hint.get(field_name, "x")
        steps.append(f'Given a request payload with "{field_name}" set to "{field_value}"')
        steps.append(f'And the value is below the minimum length requirement')
        if requires_auth:
            steps.append("And the user is authenticated")
        steps.append(f'When I send a {method} request to "{test_path}"')
        steps.append(f'Then the response status should be {scenario.expected_status}')
        steps.append('And the response should indicate the boundary violation')

    return steps
